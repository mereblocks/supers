use core::time;
use std::{
    collections::HashMap,
    process::{Child, Command, ExitStatus},
    sync::{Arc, Mutex},
    thread::{self, JoinHandle},
};

use crossbeam::channel::{unbounded, Receiver, Sender};
use tracing::{debug, debug_span, instrument, warn};

use crate::{
    errors::SupersError,
    messages::CommandMsg,
    state::{ApplicationState, ProgramStatus},
    ProgramConfig, RestartPolicy,
};

type SupersChild = Option<Child>;

// Amount of time the command thread will wait for a command message on the command channel.
pub const WAIT_TIMEOUT: time::Duration = time::Duration::from_millis(10);

/// Function to start a program with config given by, `p`, in a child process.
#[instrument(level = "debug")]
pub fn start_child_program(p: &ProgramConfig) -> Result<Child, SupersError> {
    debug!("spawning child");
    Command::new(&p.cmd)
        .args(&p.args)
        .envs(&p.env)
        .spawn()
        .map_err(|e| {
            SupersError::ProgramProcessSpawnError(p.name.to_string(), e)
        })
}

/// Update the status of program with name, `pgm_name`, to status, `status`.
/// This function panics if it cannot lock the app_state object.
#[instrument(level = "debug", skip(app_state))]
pub fn update_pgm_status(
    app_state: Arc<Mutex<ApplicationState>>,
    pgm_name: &str,
    status: ProgramStatus,
) {
    debug!("updating program status");
    let mut a = app_state.lock().unwrap();
    *a.programs.entry(pgm_name.into()).or_insert(status) = status;
}

#[derive(Debug, PartialEq)]
enum Action {
    ResetChild,
    SpawnChild,
    KillChild,
    ApplyPolicy(ExitStatus),
    UpdateStatus(ProgramStatus),
}

#[instrument(level = "debug", skip_all, fields(program = program_config.name))]
fn run_state_machine_with_effects(
    program_config: &ProgramConfig,
    app_state: Arc<Mutex<ApplicationState>>,
    cmd_tx: Sender<CommandMsg>,
    cmd_rx: Receiver<CommandMsg>,
) -> Result<(), SupersError> {
    debug!("run full state machine");
    let mut current_child: SupersChild = None;
    loop {
        let msg = cmd_rx.recv_timeout(WAIT_TIMEOUT).ok();
        let _span = debug_span!("message_span", ?msg).entered();
        debug!("received command message");
        let status =
            get_child_status(&program_config.name, &mut current_child)?;
        let actions = state_machine_step(&status, &msg);
        run_actions(
            &actions,
            &mut current_child,
            &cmd_tx,
            program_config,
            app_state.clone(),
        )?;
    }
}

// Process next step in the state machine.
// The states of the machine are values of type `ChildStatus`.
// The transitions are generated by values of type `Option<CommandMsg>` plus
// automatic transitions defined by the policies (for example: from `Exited(.)`
// to `Alive` when the policy is RestartAlways).
#[instrument(level = "debug")]
fn state_machine_step(
    status: &ChildStatus,
    msg: &Option<CommandMsg>,
) -> Vec<Action> {
    debug!("one step of the state machine");
    match (status, msg) {
        (ChildStatus::NoChild, None) => {
            // There is no child and no command to process.
            // Definitely nothing to do here.
            vec![]
        }
        (ChildStatus::NoChild, Some(CommandMsg::Start)) => {
            vec![
                Action::SpawnChild,
                Action::UpdateStatus(ProgramStatus::Running),
            ]
        }
        (
            ChildStatus::NoChild,
            Some(CommandMsg::Restart | CommandMsg::Stop),
        ) => {
            // If we don't have a child, `Stop` does nothing.
            // TODO: Do we want `Restart` to spawn a child?
            vec![]
        }
        (ChildStatus::Alive, None) => {
            // Everything running smoothly and no command. Don't disturb it :-)
            vec![]
        }
        (ChildStatus::Alive, Some(CommandMsg::Start)) => {
            // Child is running, so no sense in "starting" it. Do nothing.
            vec![]
        }
        (ChildStatus::Alive, Some(CommandMsg::Stop)) => {
            vec![
                Action::KillChild,
                Action::UpdateStatus(ProgramStatus::Stopped),
                Action::ResetChild,
            ]
        }
        (ChildStatus::Alive, Some(CommandMsg::Restart)) => {
            vec![Action::KillChild, Action::SpawnChild]
        }
        (ChildStatus::Exited(code), None) => {
            // The child exited, and there is no command in the queue.
            // Let's apply the policies, if any.
            vec![
                Action::UpdateStatus(ProgramStatus::Stopped),
                Action::ApplyPolicy(*code),
            ]
        }
        (ChildStatus::Exited(_), Some(CommandMsg::Stop)) => {
            // Child has exited, so we ignore the `Stop` command
            vec![Action::UpdateStatus(ProgramStatus::Stopped)]
        }
        (
            ChildStatus::Exited(_),
            Some(CommandMsg::Start | CommandMsg::Restart),
        ) => {
            // Child has exited, so we ignore the `Stop` command
            vec![
                Action::SpawnChild,
                Action::UpdateStatus(ProgramStatus::Running),
            ]
        }
    }
}

#[instrument(level = "debug", skip_all, fields(?actions))]
fn run_actions(
    actions: &[Action],
    child: &mut SupersChild,
    tx: &Sender<CommandMsg>,
    program_config: &ProgramConfig,
    app_state: Arc<Mutex<ApplicationState>>,
) -> Result<(), SupersError> {
    debug!("processing all actions");
    for action in actions {
        run_action(action, child, tx, program_config, app_state.clone())?;
    }
    Ok(())
}

#[instrument(level = "debug", skip_all, fields(?action))]
fn run_action(
    action: &Action,
    child: &mut SupersChild,
    tx: &Sender<CommandMsg>,
    program_config: &ProgramConfig,
    app_state: Arc<Mutex<ApplicationState>>,
) -> Result<(), SupersError> {
    debug!("processing action");
    match action {
        Action::ResetChild => {
            *child = None;
        }
        Action::SpawnChild => {
            *child = Some(start_child_program(program_config)?);
        }
        Action::KillChild => {
            child
                .as_mut()
                .map(|c| {
                    c.kill().unwrap_or_else(|e| {
                        warn!(
                            pid = c.id(),
                            error = ?e,
                            "process already exited"
                        );
                    });
                    c.wait()
                })
                .unwrap_or_else(|| {
                    unreachable!(
                        "Asked to kill non-existent child. This is a bug."
                    )
                })?;
        }
        Action::ApplyPolicy(code) => {
            match program_config.restartpolicy {
                RestartPolicy::Always => {
                    // Under this policy, we **always** restart
                    tx.send(CommandMsg::Start)?;
                }
                RestartPolicy::Never => {
                    // Do nothing, keep in `Exited` state.
                }
                RestartPolicy::OnError => {
                    // We restart if `code` is an error
                    if !code.success() {
                        tx.send(CommandMsg::Start)?;
                    }
                }
            }
        }
        Action::UpdateStatus(status) => {
            update_pgm_status(app_state, &program_config.name, *status);
        }
    }
    Ok(())
}

#[derive(Debug)]
enum ChildStatus {
    NoChild,
    Alive,
    Exited(ExitStatus),
}

// Get status of child with the meaning:
//   NoChild   -> we still don't have any child spawned
//   Alive     -> the child is running
//   Exited(s) -> the child exited with status `s`
// Return `Err` if we got an error while retrieving status.
// This function **does not** block.
fn get_child_status(
    name: &str,
    child: &mut SupersChild,
) -> Result<ChildStatus, SupersError> {
    child
        .as_mut()
        .map(|child| {
            child.try_wait().map(|status| {
                status
                    .map(ChildStatus::Exited)
                    .unwrap_or(ChildStatus::Alive)
            })
        })
        .unwrap_or_else(|| Ok(ChildStatus::NoChild))
        .map_err(|e| {
            SupersError::ProgramCheckProcessStatusError(name.into(), e)
        })
}

/// Type alias for the start_program_threads return type; A tuple type containing the thread handles for each thread
/// started as well as a hashmap of the command channels created for each program in the App config.
type ProgramControls = (
    Vec<JoinHandle<Result<(), SupersError>>>,
    HashMap<String, Sender<CommandMsg>>,
);

/// Main entrypoint for the programs.rs module; For each program in the app_config, this function:
/// 1) creates a command channel to process commands from the administrative API
/// 2) starts a thread to run and monitor the program, passing in the command channel.
#[instrument(level = "debug", skip_all)]
pub fn start_program_threads(
    app_config: Vec<ProgramConfig>,
    app_state: &Arc<Mutex<ApplicationState>>,
) -> Result<ProgramControls, SupersError> {
    let mut handles = vec![];
    let mut send_channels = HashMap::new();
    // start a thread for each program in the config
    debug!("starting threads for all programs");
    for program in app_config {
        debug!(program = program.name, "starting thread for program");
        let (tx, rx) = unbounded::<CommandMsg>();
        {
            let program = program.clone();
            let program_name = program.name.clone();
            let tx = tx.clone();
            let app_state = app_state.clone();
            let handle = thread::Builder::new()
                .name(program_name.clone())
                .spawn(move || -> Result<(), SupersError> {
                    run_state_machine_with_effects(&program, app_state, tx, rx)
                })
                .map_err(|e| {
                    SupersError::ProgramThreadStartError(program_name, e)
                })?;
            handles.push(handle);
        }
        send_channels.insert(program.name.clone(), tx);
    }

    Ok((handles, send_channels))
}

#[cfg(test)]
mod test {
    use crate::{
        config::{ProgramConfig, RestartPolicy},
        messages::CommandMsg,
        programs::{run_action, state_machine_step, Action, ChildStatus},
        state::ProgramStatus,
    };
    use anyhow::Result;
    use crossbeam::channel::unbounded;
    use std::{
        process::Command,
        sync::{Arc, Mutex},
    };
    use test_log::test;

    #[test]
    fn test_state_machine_step() -> Result<()> {
        let s = state_machine_step(&ChildStatus::NoChild, &None);
        assert!(s.is_empty());
        let s =
            state_machine_step(&ChildStatus::NoChild, &Some(CommandMsg::Start));
        assert_eq!(
            s,
            vec![
                Action::SpawnChild,
                Action::UpdateStatus(ProgramStatus::Running)
            ]
        );

        let status = Command::new("true").spawn()?.wait()?;
        let s = state_machine_step(&ChildStatus::Exited(status), &None);
        assert!(s.contains(&Action::UpdateStatus(ProgramStatus::Stopped)));

        let status = Command::new("false").spawn()?.wait()?;
        let s = state_machine_step(&ChildStatus::Exited(status), &None);
        assert!(s.contains(&Action::UpdateStatus(ProgramStatus::Stopped)));

        let status = Command::new("false").spawn()?.wait()?;
        let s = state_machine_step(
            &ChildStatus::Exited(status),
            &Some(CommandMsg::Stop),
        );
        assert!(s.contains(&Action::UpdateStatus(ProgramStatus::Stopped)));
        Ok(())
    }

    #[test]
    fn test_action() -> Result<()> {
        let p: ProgramConfig = Default::default();
        let s = Arc::new(Mutex::new(Default::default()));
        let (sx, rx) = unbounded();

        let mut child = None;
        run_action(&Action::ResetChild, &mut child, &sx, &p, s.clone())?;
        assert!(child.is_none());

        let mut child = Some(Command::new("true").spawn()?);
        run_action(&Action::ResetChild, &mut child, &sx, &p, s.clone())?;
        assert!(child.is_none());

        let p = ProgramConfig {
            name: "cat".into(),
            cmd: "cat".into(),
            ..Default::default()
        };
        run_action(&Action::SpawnChild, &mut child, &sx, &p, s.clone())?;
        assert!(child.is_some());
        run_action(&Action::KillChild, &mut child, &sx, &p, s.clone())?;
        run_action(&Action::KillChild, &mut child, &sx, &p, s.clone())?;
        child.as_mut().unwrap().wait()?;
        run_action(&Action::KillChild, &mut child, &sx, &p, s.clone())?;

        let status = Command::new("true").spawn()?.wait()?;
        run_action(
            &Action::ApplyPolicy(status),
            &mut child,
            &sx,
            &p,
            s.clone(),
        )?;
        // Default policy is restart always
        let resp = rx.recv()?;
        assert_eq!(resp, CommandMsg::Start);

        let p = ProgramConfig {
            name: "cat".into(),
            cmd: "cat".into(),
            restartpolicy: RestartPolicy::OnError,
            ..Default::default()
        };
        run_action(
            &Action::ApplyPolicy(status),
            &mut child,
            &sx,
            &p,
            s.clone(),
        )?;
        // Should not restart on success
        let resp = rx.try_recv();
        assert!(resp.is_err());

        let status = Command::new("false").spawn()?.wait()?;
        run_action(&Action::ApplyPolicy(status), &mut child, &sx, &p, s)?;
        // Should restart on error
        let resp = rx.recv()?;
        assert_eq!(resp, CommandMsg::Start);

        Ok(())
    }
}
